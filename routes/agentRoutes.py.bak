"""
Finance Service API Routes.

This module defines the FastAPI routes for the Finance Service API, 
including health checks and agent endpoints for financial queries.
"""
import os
import datetime
import json
from typing import Dict, Any, Optional, List, Set, Union
import requests
from fastapi import FastAPI, APIRouter, Request, Query, HTTPException
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.templating import Jinja2Templates
from agno.agent import RunResponse, Agent
from agno.models.nebius import Nebius
from controllers.agents import multi_ai, STOCK_PRICE_INDICATORS, FUNDAMENTAL_INDICATORS
import dotenv
from controllers.ask import chat_agent

router = APIRouter()

dotenv.load_dotenv()
NEBIUS_API_KEY: str = os.getenv("NEBIUS_API_KEY")
templates = Jinja2Templates(directory="templates")

# Define stock-related keywords as a set for more efficient lookups
STOCK_RELATED_KEYWORDS: Set[str] = {
    "stock", "price", "share", "ticker", "market cap", "p/e", 
    "dividend", "eps", "revenue"
}


def is_stock_related_query(query: str) -> bool:
    """
    Determine if a query is related to stocks or financial data.
    
    Uses set operations for efficient keyword matching.
    
    Args:
        query: The user's query string
        
    Returns:
        True if the query is stock-related, False otherwise
    """
    query_lower = query.lower()
    query_words = set(query_lower.split())
    return bool(query_words.intersection(STOCK_RELATED_KEYWORDS) or
                any(keyword in query_lower for keyword in STOCK_RELATED_KEYWORDS))


def validate_stock_response(response_text: str) -> Dict[str, bool]:
    """
    Validate if a response contains required stock information.
    
    Args:
        response_text: The text response to validate
        
    Returns:
        Dictionary with validation results for price and fundamentals
    """
    response_lower = response_text.lower()
    return {
        'has_price': any(indicator in response_lower for indicator in STOCK_PRICE_INDICATORS),
        'has_fundamental': any(indicator in response_lower for indicator in FUNDAMENTAL_INDICATORS)
    }

@router.get("/health", response_class=HTMLResponse)
async def health_check(request: Request):
    """Health check endpoint to verify the API server status and connections."""
    try:
        response_data = {
            "status": "healthy",
            "timestamp": datetime.datetime.now().isoformat(),
            "uptime": "OK",
            "api": {
                "nebius_api": "connected" if NEBIUS_API_KEY else "not configured",
            },
            "ip": requests.get('https://api.ipify.org').text,
            "services": {
                "chat": router.url_path_for("chat"),
                "agent": router.url_path_for("ask"),
            },
        }

        # Check if request is from a browser or format is explicitly set to html
        accept_header = request.headers.get("accept", "")
        if "text/html" in accept_header:
            current_year = datetime.datetime.now().year
            return templates.TemplateResponse(
                "route.html",
                {
                    "request": request,
                    "route_path": "/health",
                    "method": "GET",
                    "full_path": str(request.url).split("?")[0],
                    "description": "Health check endpoint to verify the API server status and connections.",
                    "parameters": [
                        {"name": "format", "type": "string", "description": "Response format (html or json)"}
                    ],
                    "example_query": "",
                    "example_response": json.dumps(response_data, indent=2),
                    "current_year": current_year
                }
            )
        
        return JSONResponse(content=response_data)

    except Exception as e:
        error_response = {
            "status": "unhealthy",
            "timestamp": datetime.datetime.now().isoformat(),
            "error": str(e)
        }
        
        # Check if request is from a browser or format is explicitly set to html
        accept_header = request.headers.get("accept", "")
        if "text/html" in accept_header:
            current_year = datetime.datetime.now().year
            return templates.TemplateResponse(
                "route.html",
                {
                    "request": request,
                    "route_path": "/health",
                    "method": "GET",
                    "full_path": str(request.url).split("?")[0],
                    "description": "Health check endpoint to verify the API server status and connections.",
                    "parameters": [
                        {"name": "format", "type": "string", "description": "Response format (html or json)"}
                    ],
                    "example_query": "",
                    "example_response": json.dumps(error_response, indent=2),
                    "current_year": current_year
                }
            )
            
        return JSONResponse(content=error_response)

@router.get("/chat", response_class=HTMLResponse)
async def chat(request: Request, query: Optional[str] = None) -> Union[HTMLResponse, JSONResponse]:
    """
    API endpoint to handle user investment-related questions and return AI-generated insights.
    
    Args:
        request: FastAPI Request object
        query: User's investment question
        
    Returns:
        HTML response with documentation or JSON response with answer
    """
    """
    API endpoint to handle user investment-related questions and return AI-generated insights.
    """
    # Check if request is from a browser or format is explicitly set to html
    accept_header = request.headers.get("accept", "")
    if "text/html" in accept_header:
        current_year = datetime.datetime.now().year
        example_response = {
            "question": "What are good tech stocks to invest in?",
            "answer": "Some popular tech stocks to consider include Apple (AAPL), Microsoft (MSFT), Google (GOOGL), and Amazon (AMZN). However, you should always do your own research and consider your investment goals and risk tolerance before investing."
        }
        
        return templates.TemplateResponse(
            "route.html",
            {
                "request": request,
                "route_path": "/chat",
                "method": "GET",
                "full_path": str(request.url).split("?")[0],
                "description": "Chat endpoint that uses Nebius's LLaMa model to answer investment questions.",
                "parameters": [
                    {"name": "query", "type": "string", "description": "The investment question to ask"},
                    {"name": "format", "type": "string", "description": "Response format (html or json)"}
                ],
                "example_query": "What are good tech stocks to invest in?",
                "example_response": json.dumps(example_response, indent=2),
                "current_year": current_year
            }
        )
    
    # Handle regular API calls
    if not query:
        return JSONResponse(content={"error": "Query parameter is required"})
    
    try:
        response = chat_agent.run(query)
        answer = response.content
        return JSONResponse(content={"question": query, "answer": answer})
    
    except Exception as e:
        return JSONResponse(content={"error": str(e)})

@router.get("/agent", response_class=HTMLResponse)
async def ask(request: Request, query: Optional[str] = None) -> Union[HTMLResponse, JSONResponse]:
    """
    API endpoint to handle user investment-related questions and return AI-generated insights.
    
    Args:
        request: FastAPI Request object
        query: User's investment question
        
    Returns:
        HTML response with documentation or JSON response with financial data
    """
    # Check if request is from a browser or format is explicitly set to html
    accept_header = request.headers.get("accept", "")
    if "text/html" in accept_header:
        current_year = datetime.datetime.now().year
        example_response = {
            "question": "What is the current stock price and fundamentals of Apple?",
            "answer": "# Apple Inc. (AAPL) Financial Data\n\n## Current Stock Price\nThe current stock price of Apple Inc. (AAPL) is **$198.76**.\n\n## Key Fundamentals\n- Market Cap: $3.12 trillion\n- P/E Ratio: 32.14\n- Dividend Yield: 0.51%\n\n## Recent Performance\nApple has shown strong performance with a 15.4% gain year-to-date. The company recently reported quarterly earnings that exceeded analyst expectations.\n\n*Data as of August 15, 2024*"
        }
        
        return templates.TemplateResponse(
            "route.html",
            {
                "request": request,
                "route_path": "/agent",
                "method": "GET",
                "full_path": str(request.url).split("?")[0],
                "description": "Agent endpoint that uses a multi-AI system to provide sophisticated investment advice and financial data.",
                "parameters": [
                    {"name": "query", "type": "string", "description": "The investment question to ask"},
                    {"name": "format", "type": "string", "description": "Response format (html or json)"}
                ],
                "example_query": "What is the current stock price and fundamentals of Apple?",
                "example_response": json.dumps(example_response, indent=2),
                "current_year": current_year
            }
        )
    
    # Handle regular API calls
    if not query:
        return JSONResponse(content={"error": "Query parameter is required"})
    
    try:
        # Check if the query is stock-related using our helper function
        query_is_stock_related = is_stock_related_query(query)
        
        response: RunResponse = multi_ai.run(query)
        answer = response.content
        
        # Validate response for stock-related queries
        if query_is_stock_related:
            # Use the validation helper function
            validation_results = validate_stock_response(answer)
            
            if not (validation_results['has_price'] and validation_results['has_fundamental']):
                # Retry with more explicit instructions
                retry_query = f"Please provide the CURRENT STOCK PRICE and at least one FUNDAMENTAL METRIC (like P/E ratio, market cap) for this query: {query}"
                response = multi_ai.run(retry_query)
                answer = response.content

        return JSONResponse(content={"question": query, "answer": answer})
    
    except Exception as e:
        error_msg = str(e)
        # Provide more specific error messages for stock-related queries
        if is_stock_related_query(query):
            error_msg = f"Unable to fetch current stock information: {error_msg}. Please try again later or specify the company name more clearly."
        return JSONResponse(
            status_code=500,
            content={"error": error_msg}
        )
